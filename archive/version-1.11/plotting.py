"""Plotting utilities for cosmic integration dasein.

This module provides a single convenience function for generating a
multiâ€‘panel diagnostic figure from the output of
:func:`~cosmic_integration_dasein.core.find_detection_rate`.  The
expected input is a NumPy NPZ file containing at least the keys
``redshift``, ``formation_rate``, ``merger_rate``, ``detection_rate``,
``mchirp`` and ``detection_weight_per_binary``.  The plotting function
reproduces the qualitative layout of the original cosmic integration
summary figure, featuring formation and merger rates, the cumulative
detection rate and the mass distribution of detected systems.

Example
-------

>>> from cosmic_integration_dasein.plotting import generate_plot
>>> generate_plot('results.npz', 'plot.png')

The resulting PNG is written to the specified output path.
"""

from __future__ import annotations

import pathlib
from typing import Optional

import matplotlib.pyplot as plt
import numpy as np


def generate_plot(npz_path: str, output_path: str = "plot.png") -> None:
    """Create a four panel summary plot from a results NPZ archive.

    Parameters
    ----------
    npz_path : str
        Path to the NPZ file generated by
        :func:`~cosmic_integration_dasein.core.find_detection_rate`.
    output_path : str, optional
        Path of the PNG file to write.  If the path contains
        directories they must already exist.

    Raises
    ------
    FileNotFoundError
        If the NPZ file does not exist.
    KeyError
        If required keys are missing from the NPZ archive.
    """
    p = pathlib.Path(npz_path)
    if not p.exists():
        raise FileNotFoundError(f"Result file {npz_path} not found")
    data = np.load(p, allow_pickle=True)
    required = [
        "redshift",
        "formation_rate",
        "merger_rate",
        "detection_rate",
        "mchirp",
        "detection_weight_per_binary",
    ]
    for key in required:
        if key not in data:
            raise KeyError(f"Required dataset '{key}' missing from NPZ file")
    z = np.asarray(data["redshift"], dtype=float)
    formation_rate = np.asarray(data["formation_rate"], dtype=float)
    merger_rate = np.asarray(data["merger_rate"], dtype=float)
    detection_rate = np.asarray(data["detection_rate"], dtype=float)
    mchirp = np.asarray(data["mchirp"], dtype=float)
    det_weights = np.asarray(data["detection_weight_per_binary"], dtype=float)
    # Normalise detection weights for histogram
    if det_weights.sum() > 0:
        det_weights_norm = det_weights / det_weights.sum()
    else:
        det_weights_norm = det_weights
    # Cumulative detection rate normalised to one
    det_cumulative = np.cumsum(detection_rate)
    if det_cumulative[-1] > 0:
        det_cumulative /= det_cumulative[-1]
    # Generate figure
    fig, axs = plt.subplots(2, 2, figsize=(10, 8))
    # Top left: formation rate
    ax = axs[0, 0]
    ax.plot(z, formation_rate, color="tab:blue")
    ax.set_xlabel("Redshift")
    ax.set_ylabel("Formation rate [arb. units]")
    ax.set_title("Formation rate vs redshift")
    # Top right: merger rate
    ax = axs[0, 1]
    ax.plot(z, merger_rate, color="tab:orange")
    ax.set_xlabel("Redshift")
    ax.set_ylabel("Merger rate [arb. units]")
    ax.set_title("Merger rate vs redshift")
    # Bottom left: cumulative detection rate
    ax = axs[1, 0]
    ax.plot(z, det_cumulative, color="tab:green")
    ax.set_xlabel("Redshift")
    ax.set_ylabel("Cumulative detection fraction")
    ax.set_title("Cumulative detection rate vs redshift")
    # Bottom right: mass distribution
    ax = axs[1, 1]
    # Use 50 bins spanning range of mchirp
    if len(mchirp) > 0:
        bins = np.linspace(mchirp.min(), mchirp.max(), 51)
        ax.hist(
            mchirp,
            bins=bins,
            weights=det_weights_norm,
            histtype="stepfilled",
            color="tab:red",
        )
    ax.set_xlabel("Chirp mass, $\mathcal{M}_c$ [M$_\odot$]")
    ax.set_ylabel("Normalised detections")
    ax.set_title("Mass distribution of detections")
    # Adjust layout and save
    fig.tight_layout()
    fig.savefig(output_path, dpi=300)
    plt.close(fig)